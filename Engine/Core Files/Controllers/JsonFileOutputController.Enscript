/*
  Created By: Bibek Baniya (thebibekbaniya@gmail.com)
  Date: 2021-11-24
  Location: Edmonton, Alberta, Canada

  This Controller will output carved images and movies into JSON.
*/

include "..\\Controllers\\ConsoleController"
include "..\\Controllers\\DataController"
include "..\\Controllers\\HashController"
include "..\\Controllers\\XMLCharacterController"
include "..\\Models\\PictureCarveClass"
include "..\\Models\\MovieCarveClass"
include "..\\..\\Classes\\OptionsClass"

class JsonFileOutputController {
	BookmarkClass           BookmarkRoot,
						    ExcludeRoot,
						    FailedRoot;
	
	ConsoleController       MyConsole;
	DataController          MyData;
	HashController          MyHash;
	LocalFileClass          ReportIndex,
					        CaseReport,
						    CurrentReport,
						    DebugReport,
						    VictimReport,
						    ZipReport;

	int						Cat1;
	int						Cat2;
	int						Cat3;
	int						Cat4;
	int						Cat5;
	int						Cat6;
	int						Cat7;
	int						Cat8;
	int						Cat9;
	int						Cat10;
	int						Cat11;
	int						CatX;
	int						DiskId;
	int						SubDiskId;
	
	
	long                    DebugReportId,
						    DebugReportSize,
						    FileCount,
                            MovieCount,
                            PictureCount,
						    ExcludedSmallCount;
	
	long                    ExportToFolderCount;
	long                    SubFolderSize;
	long                    FailedCount;
	long                    FolderSize;
	long                    LocalFileCount;
	
	OptionsClass            MyOptions;
	
    String                  MyCaseNumber;
	String                  FolderName;
	String                  MyReportPath;
	String                  SubFolderName;

    JsonFileOutputController(OptionsClass myOptions, DataController myData, ConsoleController myConsole){
        MyOptions = myOptions;
        MyData = myData;
        MyConsole = myConsole;
        ReportIndex     = new LocalFileClass();
        CaseReport      = new LocalFileClass();
        CurrentReport   = new LocalFileClass();
        DebugReport     = new LocalFileClass();
        VictimReport    = new LocalFileClass();
        ZipReport       = new LocalFileClass();
        MyHash          = new HashController();
        //MyConsole       = new ConsoleController(MyOptions);
        DebugReportId   = 1;
        DebugReportSize = 0;
    }

    String GetIndexPath(){
        String val = MyReportPath + "\\Enscript Index.json";
        return val;
    }

    void OpenIndexFile(bool append){
        String outputIndexFilePath = GetIndexPath();
        if (!ReportIndex.IsOpen()){
            if(append){
                if(!ReportIndex.Open(outputIndexFilePath, FileClass::APPEND)){
                    MyConsole.WriteFullLine("Could not open: " + outputIndexFilePath);
                    Message("Critical Failure!", "Index File could not be opened!!!");
                    SystemClass::Exit();
                }
            } else {
                if(!ReportIndex.Open(outputIndexFilePath, FileClass::WRITETEXTCRLF)){
                    MyConsole.WriteFullLine("Could not open: " + outputIndexFilePath);
                    Message("Critical Failure!", "Index File could not be opened!!!");
                    SystemClass::Exit();
                    }       
                }

        }
        ReportIndex.SetCodePage(CodePageClass::UNICODE);
    }

    void Initialize(bool trustMe, ActivePlugins plugins){

        // Create Default Bookmark Structure
        //BookmarkRoot = new BookmarkClass(MyOptions.Case.BookmarkRoot(), "");
        BookmarkRoot = new BookmarkClass(MyOptions.Case.BookmarkRoot(), "Image Results - " + MyOptions.StartDate + " " + MyOptions.StartTime, NodeClass::FOLDER);

        // And then, if desired, add pre-cat folders
        if(MyOptions.MakeBookmarks)
            BookmarkRoot.SetComment("Results categorized from Hash Database");

        BookmarkTextClass note(BookmarkRoot, "Note", 0);
        note.SetComment("EnScript Compile Date: " + MyOptions.CompileDate);

        // Case Root
        MyReportPath = MyOptions.ReportPath + "\\VicCarver - " + MyOptions.CaseName;
        if (!LocalMachine.PathExists(MyReportPath)){
            if(!LocalMachine.CreateFolder(MyReportPath))
                MyConsole.WriteFullLine("Could not create the Case Root! (" + MyReportPath  + ")");
        }

        // Write the script's Settings to a text file
        SaveSettings(plugins);

        // PASSWORD PROTECTED FILES
        if(!LocalMachine.PathExists(MyReportPath + "\\Protected Files")){
            if(!LocalMachine.CreateFolder(MyReportPath + "\\Protected Files"))
                MyConsole.WriteFullLine("Could not create the Protected Files Folder! (" + MyReportPath + "\\Protected Files)");
        }       

        MyOptions.ProtectedPath = MyReportPath + "\\Protected Files\\";

        // CASE REPORT
        StartCaseReport(trustMe);

        // DEBUG Report
        if(MyOptions.Debug){
            String path = MyReportPath + "\\Debug";
            if (!LocalMachine.PathExists(path)){
                if(!LocalMachine.CreateFolder(path))
                    MyConsole.WriteFullLine("Could not create the Index Report! (" + path + ")");
            }

            if(MyOptions.DebugCurrentOnly){
                if(!CurrentReport.Open(path + "\\Current Report.txt", FileClass::WRITE))
                    MyConsole.WriteFullLine("Could not open: " + path + "\\Current Report.txt");
                    CurrentReport.SetCodePage(CodePageClass::ANSI);
                    CurrentReport.Close();
            }
        else {
            if(!MyOptions.DebugCurrentOnly){
                path = path + "\\Debug Report_" + DebugReportId + ".txt";
                 if(!DebugReport.Open(path, FileClass::WRITE))
                    MyConsole.WriteFullLine("Could not open: " + path);
                    DebugReport.SetCodePage(CodePageClass::ANSI);
                }
            }
        }

         // Excluded Bookmarks
        if(MyOptions.ExcludePreCatVal > 0)
            ExcludeRoot = new BookmarkClass(BookmarkRoot, "Excluded by Pre-Cat", NodeClass::FOLDER);

        // Failed Bookmarks
        FailedRoot = new BookmarkClass(BookmarkRoot, "Failed to Extract", NodeClass::FOLDER);

        // First Export Folder
        if(!MyOptions.ExportByHash)
            MakeNewFolder();


        // Index.json
        StartIndexFile();

        //TODO
        // Victim Report.xml
        String path = MyReportPath + "\\Victim Report.xml";
        if(VictimReport.Open(path, FileClass::WRITETEXTCRLF)){
            VictimReport.WriteLine("<?xml version=\"1.0\" encoding=\"utf-16\"?>");
            VictimReport.WriteLine("  <VictimIndex>\r\n");
            VictimReport.Close();
        } else
            MyConsole.WriteFullLine("Could not open: " + path);
    }

    void StartIndexFile(){        
        //Set up the start of JSON output file
        if(!this) return;
            OpenIndexFile(false);

            GUIDClass guid();
            guid.Create();
            MyCaseNumber = guid;

        String fileStartIndex = "{" +
	                        "\"odata.metadata\": \"http://github.com/ICMEC/ProjectVic/DataModels/1.3.xml#Cases\","+
	                        "\"value\": [{"+
			                    "\"odata.id\": \"Case(\\\""+ MyCaseNumber +"\\\")\"," +
			                    "\"Media@odata.navigationLinkUrl\": \"/Case("+ MyCaseNumber+")/Media\"," +
			                    "\"Media\": [";
        ReportIndex.WriteLine(fileStartIndex);
    }

    void EndIndexFile(){
        //Set up the end of JSON output file
        if(!this) return;
        OpenIndexFile(true);

        String fileEndIndex = "],\"CaseID\": \""+ MyCaseNumber +"\"," +
                                "\"CaseNumber\": \""+MyOptions.CaseName     +"\",\r\n" + 
                                "\"ContactName\": \""+MyOptions.ForensicAnalyst     +"\",\r\n" + 
                                "\"SourceApplicationName\": \"VicsCarver\",\r\n" + 
                                "\"SourceApplicationVersion\": \""+MyOptions.VersionNum     +"\"\r\n" + 
                                "}]}";

        ReportIndex.WriteLine(fileEndIndex);
        ReportIndex.Close();
    }

    String PadNumber(int val){
        // ## Formatting Operations
        if(!this) return "";

        String newVal = val;
        while(newVal.GetLength() < 8)
            newVal = "0" + newVal;
        return newVal;
    }

    static String ConvertBoolToString(bool check)
    {
        if(check)
            return "true";
        return "false";
    }

    static String ReturnDateString(DateClass d){
        String dateVal;
        dateVal = d.GetString("yyyy-MM-dd", "HH:mm:ss", d.GetTimeZoneBias());
        //dateVal = d.GetUnix() - d.GetTimeZoneBias();
        dateVal.Replace(" ", "T", 0, -1, 0);
        return dateVal;
    }

    void Message(const String &title, const String &body){
        if(!this) return;
        SystemClass::Message(SystemClass::MBOK, title, body);
    }

    void AddPictureBookmark(BookmarkClass parent, const String &name, const String &comment, EntryClass e, long fileOffset, long fileSize){
        BookmarkDecodeClass data(parent, name);
        data.CopyItemData(e);
        data.SetDataSize(fileSize);
        data.SetDataOffset(fileOffset);
        data.SetCodingType(PICTURE);
        data.SetComment(comment);
    }

    void ClearCurrentReport(){
        // ## File / Folder Output
        if(!this) return;

        if(CurrentReport.IsOpen())
            CurrentReport.Close();

        String path = MyReportPath + "\\Debug\\Current Report.txt";
        if(!CurrentReport.Open(path, FileClass::WRITE))
            MyConsole.WriteFullLine("Could not open: " + path);
        CurrentReport.SetCodePage(CodePageClass::ANSI);
    }

    void WriteDebug(const String &source, const String &val){
        if(!this) return;
        
        String line = "##" + source + "##: " + val;
        
        if(MyOptions.DebugCurrentOnly){
            if(!CurrentReport.IsOpen()){
                String path = MyReportPath + "\\Debug\\Current Report.txt";
                if(!CurrentReport.Open(path, FileClass::APPEND))
                    MyConsole.WriteFullLine("Could not open: " + path);
                CurrentReport.SetCodePage(CodePageClass::ANSI);
            }
            CurrentReport.WriteLine(line);
            //CurrentReport.Close();
        }
        else {
            if(!DebugReport.IsOpen()){
                String path = MyReportPath + "\\Debug\\Debug Report_" + DebugReportId + ".txt";
                if(!DebugReport.Open(path, FileClass::APPEND))
                    MyConsole.WriteFullLine("Could not open: " + path);
                DebugReport.SetCodePage(CodePageClass::ANSI);
            }
        
            DebugReport.WriteLine(line);
            DebugReportSize = DebugReportSize + line.GetLength() ;
            //DebugReport.Close();
        
            if(DebugReportSize > 50000000){
                DebugReportId++;
                DebugReportSize = 0;
                DebugReport.Close();
            }
        }
    }

//TODO
    void StartCaseReport(bool trustMe){
        if(!this) return;

        LocalFileClass lf();

        String encaseVersion = SystemClass::MajorVersion() + "." + SystemClass::MinorVersion() + "." + SystemClass::SubMajorVersion() + "." + SystemClass::SubMinorVersion();

        if (lf.Open(MyReportPath + "\\Case Report.xml", FileClass::WRITETEXTCRLF)) {
            lf.WriteLine("<?xml version=\"1.0\" encoding=\"utf-16\"?>");
            lf.WriteLine("  <CaseReport>");
            lf.WriteLine("    <CaseNumber><![CDATA["     + MyOptions.CaseName        + "]]></CaseNumber>");
            lf.WriteLine("    <Analyst><![CDATA["        + MyOptions.ForensicAnalyst + "]]></Analyst>");
            lf.WriteLine("    <Date><![CDATA["           + MyOptions.StartDate       + "]]></Date>");
            lf.WriteLine("    <Time><![CDATA["           + MyOptions.StartTime       + "]]></Time>");
            lf.WriteLine("    <Comment><![CDATA["        + MyOptions.Comments        + "]]></Comment>");

            if(!trustMe)
              lf.WriteLine("    <ScriptVersion><![CDATA[EnScript v"  + MyOptions.VersionNum      + "]]></ScriptVersion>");
            else
              lf.WriteLine("    <ScriptVersion><![CDATA['Trust Me' EnScript v"  + MyOptions.VersionNum      + "]]></ScriptVersion>");

            lf.WriteLine("    <EnCaseVersion><![CDATA[EnCase v"  + encaseVersion              + "]]></EnCaseVersion>");

        } else
            MyConsole.WriteFullLine("Could not copy the case report! (" + MyReportPath + "\\Case Report.xml)");
        lf.Close();
    }

//TODO
    void EndCaseReport(){
        if(!this) return;

        LocalFileClass lf();
        if (lf.Open(MyReportPath + "\\Case Report.xml", FileClass::APPEND)) {
            lf.WriteLine("    <Excluded><![CDATA["  +  CatX  + "]]></Excluded>");
            lf.WriteLine("  </CaseReport>");
        } else
            MyConsole.WriteFullLine("Could not reopen the case report! (" + MyReportPath + "\\Case Report.xml)");
        lf.Close();
    }

    void CarvePicture(PictureCarveClass pc, const String &path){
        if(pc){
            // 1. an EntryFile class if required
            EntryFileClass ef();
            if(!pc.MF){
                ef.Open(pc.Entry, FileClass::SLACK | FileClass::NOINITIALIZE);
                    if(!ef)
                        MyConsole.WriteFullLine("Failed to open entry: " + path + pc.Entry.FullPath());
            }

            // 2. Get the file's MD5 and SHA1 hashes
            String hash;
            String hash2;
            String sha1Hash;

            if(pc.MF)
            {
                pc.MF.Seek(0);
                hash = MyHash.GetMd5Hash(pc.MF, pc.FileLength);

                pc.MF.Seek(0);
                sha1Hash = MyHash.GetSha1Hash(pc.MF, pc.FileLength);

                if("jpg".Compare(pc.Extension, false) == 0)
                {
                    pc.MF.Seek(0);
                    hash2 = MyHash.GetMd5Hash(pc.MF, pc.FileLength - 2);
                }
            }
            else
            {
                ef.Seek(pc.Offset);
                hash = MyHash.GetMd5Hash(ef, pc.FileLength);

                ef.Seek(pc.Offset);
                sha1Hash = MyHash.GetSha1Hash(ef, pc.FileLength);

                if("jpg".Compare(pc.Extension, false) == 0)
                {
                    ef.Seek(pc.Offset);
                    hash2 = MyHash.GetMd5Hash(ef, pc.FileLength-2);
                }
            }

            // 3. Get the pre-category
            int category = MyData.GetCategory(hash);

            if(MyOptions.ExcludePreCatVal > 0)
            {
                if(MyOptions.ExcludePreCatVal != category){
                    if(category == 1)
                        Cat1++;
                    else if(category == 2)
                        Cat2++;
                    else if(category == 3)
                        Cat3++;
                    else if(category == 4)
                        Cat4++;
                    else if(category == 5)
                        Cat5++;
                    else if(category == 6)
                        Cat6++;
                    else if(category == 7)
                        Cat7++;
                    else if(category == 8)
                        Cat8++;
                    else if(category == 9)
                        Cat9++;
                    else if(category == 10)
                        Cat10++;
                    else if(category == 11)
                        Cat11++;

                }
                else
                    CatX++;
            }


            if(category == 0 && "jpg".Compare(pc.Extension, false) == 0) 
                category = MyData.GetCategory(hash2);


            // 4. Decide how to treat this hit:
            //    - do we ignore it because it is a user-selected "ignore" pre-category?
            //    - or do we process it
            if(MyOptions.ExcludePreCatVal == category && category > 0){
                if(MyOptions.Debug)
                    WriteDebug("OutputController", "File validated, but excluded by user (category " + category + ")");

                if(MyOptions.BookmarkExcludedPreCat)
                    AddPictureBookmark(ExcludeRoot, pc.Entry.Name(), "Excluded Pre-Cat Hit (" + category + ")", pc.Entry, pc.Offset, 10);
            }
            else {
                PictureCount++;
                FileCount++;
                LocalFileCount++;
                ExportToFolderCount++;
                FolderSize = FolderSize + pc.FileLength + 2047;


                // Decide how to identify this file once it is extracted
                String fileName;
                String outPath;
                String pathVal;

                if(MyOptions.ExportByHash){
                    // when filing by hash, we need to verify each sub-folder is present as we build the path
                    fileName = hash + "." + pc.Extension;

                    outPath = MyReportPath + "\\";

                    String hashPath;

                    hashPath = hash.SubString(0,1);
                    if(!LocalMachine.PathExists(outPath + hashPath))
                        LocalMachine.CreateFolder(outPath + hashPath);

                    hashPath = hashPath + "\\" + hash.SubString(1,1);
                    if(!LocalMachine.PathExists(outPath + hashPath))
                        LocalMachine.CreateFolder(outPath + hashPath);

                    outPath = outPath + hashPath + "\\";
                    pathVal = hashPath;
                }
                else {
                    fileName = PadNumber(FileCount) + "." + pc.Extension;
                    outPath = MyReportPath + "\\" + FolderName + "\\" + SubFolderName + "\\";
                    pathVal = FolderName + "\\" + SubFolderName;
                }

                if(outPath.GetLength() > 255){
                    Message("Script Failure", "The path of the file to be exported is TOO long.  Windows won't support this.\n\n" +
                                      "You need to change the length of your Case Name, as it is included in the root folder and every CD/DVD folder " +
                                      "or change the location of your Root Path.  The combined length of these folder names exceeds 255 characters.\n\n" +
                                      "(" + outPath + ")");
                    SystemClass::Exit();
                }

                // There are two types of files to carve out- Base 64 will be a Memory FileClass
                bool extractSuccess = false;
                if(pc.MF){
                    // 1. Copy out the Decoded data
                    extractSuccess = Extract(pc.MF, pc, outPath + fileName);
                }
                else {
                    // 2. Copy out the data
                    extractSuccess = Extract(ef, pc, outPath + fileName);
                }


                // Sometimes the export process will fail.  There are various reasons why, but if it DID fail, we don't want to write anything to the output directory
                // ...we also need to reverse the counters
                if(!extractSuccess){
                    PictureCount--;
                    FileCount--;
                    LocalFileCount--;
                    ExportToFolderCount--;
                    FolderSize = FolderSize - (pc.FileLength + 2047);
                    FailedCount++;
                }
                else {

                    // 4. Write to the Picture Library
                    CopyToLibrary(outPath + fileName, hash, pc.Extension);

                    // 6. Get the victim match info
                    String victimPath = MyData.GetVictim(hash);
                    AddVictimEntry(victimPath, hash);

                    // 7. Write in the XML
                    AddPictureJsonEntry(pc, hash, pc.Entry.HashValue(), category, path, pathVal, fileName, sha1Hash);

                    // 8.  Bookmark the picture
                    AddBookmark(pc, fileName);

                    // 9.  Update statusbar
                    MyOptions.SetStatusMessage("Found " + PictureCount + " pictures.");

                    // 10. Increment the folders if necessary
                    if(!MyOptions.ExportByHash){
                        if(FolderSize >= 4500000000)
                            MakeNewFolder();
                        else if(ExportToFolderCount >= 5000)
                        MakeNewSubFolder();
                    }
                }
            }
        }
    
    
    }

    void CarveMovie(MovieCarveClass mc, const String &path){
        MyOptions.SetStatusMessage("Carving file...");
        if(mc){
        
            // 1. an EntryFile class if required
            EntryFileClass ef();
            if(!mc.MF){
            
                ef.Open(mc.Entry, FileClass::SLACK | FileClass::NOINITIALIZE);
                if(!ef)
                    MyConsole.WriteFullLine("Failed to open entry: " + path + mc.Entry.FullPath());
            }

            // 2. Get the file's MD5 and SHA1 hashes
            String hash;
            String hash2;
            String sha1Hash;

            if(mc.MF)
            {
                mc.MF.Seek(0);
                hash = MyHash.GetMd5Hash(mc.MF, mc.FileLength);

                mc.MF.Seek(0);
                sha1Hash = MyHash.GetSha1Hash(mc.MF, mc.FileLength);

                if("jpg".Compare(mc.Extension, false) == 0)
                {
                    mc.MF.Seek(0);
                    hash2 = MyHash.GetMd5Hash(mc.MF, mc.FileLength - 2);
                }
            }
            else
            {
                ef.Seek(mc.Offset);
                hash = MyHash.GetMd5Hash(ef, mc.FileLength);

                ef.Seek(mc.Offset);
                sha1Hash = MyHash.GetSha1Hash(ef, mc.FileLength);

                if("jpg".Compare(mc.Extension, false) == 0)
                {
                  ef.Seek(mc.Offset);
                  hash2 = MyHash.GetMd5Hash(ef, mc.FileLength-2);
                }
            }

            // 3. Get the pre-category
            int category = MyData.GetCategory(hash);

            if(MyOptions.ExcludePreCatVal > 0)
            {
                if(MyOptions.ExcludePreCatVal != category){
                    if(category == 1)
                        Cat1++;
                    else if(category == 2)
                        Cat2++;
                    else if(category == 3)
                        Cat3++;
                    else if(category == 4)
                        Cat4++;
                    else if(category == 5)
                        Cat5++;
                    else if(category == 6)
                        Cat6++;
                    else if(category == 7)
                        Cat7++;
                    else if(category == 8)
                        Cat8++;
                    else if(category == 9)
                        Cat9++;
                    else if(category == 10)
                        Cat10++;
                    else if(category == 11)
                        Cat11++;
                } else
                    CatX++;
            }

            if(category == 0 && "jpg".Compare(mc.Extension, false) == 0) 
                category = MyData.GetCategory(hash2);

            // 4. Decide how to treat this hit:
            //    - do we ignore it because it is a user-selected "ignore" pre-category?
            //    - or do we process it
            if(MyOptions.ExcludePreCatVal == category && category > 0){
                if(MyOptions.Debug)
                    WriteDebug("OutputController", "File validated, but excluded by user (category " + category + ")");

                if(MyOptions.BookmarkExcludedPreCat)
                    AddPictureBookmark(ExcludeRoot, mc.Entry.Name(), "Excluded Pre-Cat Hit (" + category + ")", mc.Entry, mc.Offset, 10);
            }
            else {
                MovieCount++;
                FileCount++;
                LocalFileCount++;
                ExportToFolderCount++;
                FolderSize = FolderSize + mc.FileLength + 2047;


                // Decide how to identify this file once it is extracted
                String fileName;
                String outPath;
                String pathVal;

                if(MyOptions.ExportByHash){
                  // when filing by hash, we need to verify each sub-folder is present as we build the path
                    fileName = hash + "." + mc.Extension;

                    outPath = MyReportPath + "\\";

                    String hashPath;

                    hashPath = hash.SubString(0,1);
                    if(!LocalMachine.PathExists(outPath + hashPath))
                        LocalMachine.CreateFolder(outPath + hashPath);

                    hashPath = hashPath + "\\" + hash.SubString(1,1);
                    if(!LocalMachine.PathExists(outPath + hashPath))
                        LocalMachine.CreateFolder(outPath + hashPath);

                    outPath = outPath + hashPath + "\\";
                    pathVal = hashPath;
                }
                else {
                    fileName = PadNumber(FileCount) + "." + mc.Extension;
                    outPath = MyReportPath + "\\" + FolderName + "\\" + SubFolderName + "\\";
                    pathVal = FolderName + "\\" + SubFolderName; 
               }

                if(outPath.GetLength() > 255){
                    Message("Script Failure", "The path of the file to be exported is TOO long.  Windows won't support this.\n\n" +
                                      "You need to change the length of your Case Name, as it is included in the root folder and every CD/DVD folder " +
                                      "or change the location of your Root Path.  The combined length of these folder names exceeds 255 characters.\n\n" +
                                      "(" + outPath + ")");
                    SystemClass::Exit();
                }

                // There are two types of files to carve out- Base 64 will be a Memory FileClass
                bool extractSuccess = false;
                if(mc.MF){
                
                  // 1. Copy out the Decoded data
                    extractSuccess = Extract(mc.MF, mc, outPath + fileName);
                }

                else {
                    // 2. Copy out the data
                    extractSuccess = Extract(ef, mc, outPath + fileName);
                }

                // Sometimes the export process will fail.  There are various reasons why, but if it DID fail, we don't want to write anything to the output directory
                // ...we also need to reverse the counters
                if(!extractSuccess){
                    MovieCount--;
                    FileCount--;
                    LocalFileCount--;
                    ExportToFolderCount--;
                    FolderSize = FolderSize - (mc.FileLength + 2047);
                    FailedCount++;
                }
                else {                
                    // 4. Write to the Picture Library
                    CopyToLibrary(outPath + fileName, hash, mc.Extension);

                    // 6. Get the victim match info
                    String victimPath = MyData.GetVictim(hash);
                    AddVictimEntry(victimPath, hash);

                    // 7. Write in the XML
                    AddMovieJsonEntry(mc, hash, mc.Entry.HashValue(), category, path, pathVal, fileName, sha1Hash);

                    // 8.  Bookmark the picture
                    AddBookmark(mc, fileName);

                    // 9.  Update statusbar
                    MyOptions.SetStatusMessage("Found " + MovieCount + " videos.");

                    // 10. Increment the folders if necessary
                    if(!MyOptions.ExportByHash){
                      if(FolderSize >= 4500000000)
                        MakeNewFolder();
                      else if(ExportToFolderCount >= 5000)
                        MakeNewSubFolder();
                    }
                }
            }
        }
    }

    void AddPictureJsonEntry(PictureCarveClass pc, const String &hash, const String &encaseHash, int category, const String &path, const String &pathVal, const String &fileName, const String &sha1Hash){

        String lineValue, startingComma;
        String amcessed, created, written, modified, deleted;
        bool isPrecategorized, isDeleted, isUnallocated;
        String calcFileName, calcFullPath;    //TODO Extract filename and calcFullpath

        if(pc.Offset == 0){
            created = ReturnDateString(pc.Entry.Created());
            amcessed = ReturnDateString(pc.Entry.Accessed());
            written = ReturnDateString(pc.Entry.Written());
            modified = ReturnDateString(pc.Entry.Modified());
            deleted = ReturnDateString(pc.Entry.Deleted());
        }

        created = created.GetLength() > 0 ? ("\"Created\": \""+ created+"\",\r\n") : "";   
        written = written.GetLength() > 0 ? ("\"Written\": \""+ written+"\",\r\n") : ""; 
        amcessed = amcessed.GetLength() > 0 ? ("\"Accessed\": \""+ amcessed+"\",\r\n") : "";

        startingComma = FileCount > 1 ? "," : "";
        String fullPath = path + pc.Entry.TruePath();
        String fileNameOnly = fullPath.GetFilename();
        fullPath.Replace("\\", "\\\\");
        calcFullPath = "\\\\" + hash.SubString(0,1) +  "\\\\" + hash.SubString(1,1) + "\\\\" + fileName;
        isPrecategorized = category > 0;
        isDeleted = deleted.GetLength() > 0;
        isUnallocated = pc.Offset > 0;

        lineValue = startingComma + "{\r\n" +
                        "\"odata.id\": \"Media(\\\""            + FileCount                         +"\\\")\",\r\n"+
					    "\"MediaFiles@odata.navigationLinkUrl\": \"/Media("+ hash                   +")/MediaFiles\",\r\n"+
                        "\"MediaFiles\": [{"                  +
                            "\"Media@odata.navigationLinkUrl\": \"/MediaFiles(FileName='"+fileNameOnly+"',FilePath='"+ fullPath+"',MD5="+ hash+")/Media\",\r\n"+
							"\"MD5\": \""                          + hash                        +"\",\r\n"+
							"\"FileName\": \""                     + fileNameOnly                    +"\",\r\n"+
							"\"FilePath\": \""                     + fullPath                    +"\",\r\n"+
							created + written + amcessed +
							"\"Unallocated\": "                    + ConvertBoolToString(isUnallocated) +",\r\n"+
                            "\"PhysicalLocation\": \""             + pc.Entry.PhysicalLocation() +"\",\r\n"+
                            "\"Deleted\": "                        + ConvertBoolToString(isDeleted) +",\r\n"+
							"\"FileOffset\": \""                   + pc.Offset                   +"\",\r\n"+
							"\"Monikers\": \""                     + pc.Monikers                 +"\",\r\n"+
							"\"BitDepth\": \""                     + pc.BitDepth                 +"\",\r\n"+
							"\"AspectRatio\": \""                  + pc.AspectRatio              +"\",\r\n"+
							"\"Description\": \""                  + pc.Entry.Description()      +"\"}],\r\n"+
					    "\"MediaID\":"                             + FileCount                   +","+
					    "\"Category\": "                           + category                      +",\r\n"+
					    "\"MD5\": \""                              + hash                        +"\",\r\n"+
					    "\"VictimIdentified\":"                    + ConvertBoolToString(false)                       +",\r\n"+
					    "\"IsDistributed\":"                       + ConvertBoolToString(false)                       +",\r\n"+
					    "\"SHA1\": \""                             + sha1Hash                    +"\",\r\n"+
					    "\"MediaSize\": \""                        + pc.FileLength               +"\",\r\n"+
					    "\"RelativeFilePath\": \""                 + calcFullPath                +"\",\r\n"+
					    "\"OffenderIdentified\":"                  + ConvertBoolToString(false)                       +",\r\n"+
					    "\"IsPrecategorized\": "                   + ConvertBoolToString(isPrecategorized)  +",\r\n"+
					    "\"PrecategorizationSource\": \""          + ""                          +"\",\r\n"+
					    "\"MimeType\": \""                         + "Image"                     +"\"\r\n}\r\n"; //TODO might need to remove comma at the end

        // if necessary, reopen this file
        OpenIndexFile(true);

        // add the new record
        ReportIndex.WriteLine(lineValue);
    }

    void AddMovieJsonEntry(MovieCarveClass mc, const String &hash, const String &encaseHash, int category, const String &path, const String &pathVal, const String &fileName, const String &sha1Hash){

        String lineValue, startingComma;
        String amcessed, created, written, modified, deleted;
        bool isPrecategorized, isDeleted, isUnallocated;
        String calcFileName, calcFullPath;    //TODO Extract filename and calcFullpath

        if(mc.Offset == 0){
            created = ReturnDateString(mc.Entry.Created());
            amcessed = ReturnDateString(mc.Entry.Accessed());
            written = ReturnDateString(mc.Entry.Written());
            modified = ReturnDateString(mc.Entry.Modified());
            deleted = ReturnDateString(mc.Entry.Deleted());
        }

        created = created.GetLength() > 0 ? ("\"Created\": \""+ created+"\",\r\n") : "";   
        written = written.GetLength() > 0 ? ("\"Written\": \""+ written+"\",\r\n") : ""; 
        amcessed = amcessed.GetLength() > 0 ? ("\"Accessed\": \""+ amcessed+"\",\r\n") : "";

        startingComma = FileCount > 1 ? "," : "";
        String fullPath = path + mc.Entry.TruePath();
        String fileNameOnly = fullPath.GetFilename();

        fullPath.Replace("\\", "\\\\");
        calcFullPath = "\\\\" + hash.SubString(0,1) +  "\\\\" + hash.SubString(1,1) + "\\\\" + fileName;
        isPrecategorized = category > 0;
        isDeleted = deleted.GetLength() > 0;
        isUnallocated = mc.Offset > 0;

        lineValue = startingComma + "{\r\n" +
                        "\"odata.id\": \"Media(\\\""            + FileCount                         +"\\\")\",\r\n"+
					    "\"MediaFiles@odata.navigationLinkUrl\": \"/Media("+ hash                   +")/MediaFiles\",\r\n"+
                        "\"MediaFiles\": [{"                  +
                            "\"Media@odata.navigationLinkUrl\": \"/MediaFiles(FileName='"+fileNameOnly+"',FilePath='"+ fullPath+"',MD5="+ hash+")/Media\",\r\n"+
							"\"MD5\": \""                     + hash                        +"\",\r\n"+
        				    "\"FileName\": \""                + fileNameOnly                    +"\",\r\n"+
        				    "\"FilePath\": \""                + fullPath                    +"\",\r\n"+
        				    created+ written+ amcessed+
                            "\"Unallocated\": "               + ConvertBoolToString(isUnallocated) +",\r\n"+
        				    "\"PhysicalLocation\": \""        + mc.Entry.PhysicalLocation() +"\",\r\n"+
        				    "\"FileSize\": \""                + mc.FileLength               +"\",\r\n"+
        				    "\"SourceID\": \""                + ""                          +"\",\r\n"+
                            "\"Deleted\": "                   + ConvertBoolToString(isDeleted) +",\r\n"+
        				    "\"MovieLength\": \""             + mc.MovieLength              +"\",\r\n"+
        				    "\"FileOffset\": \""              + mc.Offset                   +"\",\r\n"+
                            "\"Monikers\": \""                + mc.Monikers                 +"\",\r\n"+
							"\"Description\": \""             + mc.Entry.Description()      +"\"}],\r\n"+
					    "\"MediaID\":"                        + FileCount                   +","+
					    "\"Category\": \""                    + category                    +"\",\r\n"+
					    "\"MD5\": \""                         + hash                        +"\",\r\n"+
					    "\"VictimIdentified\":"               + ConvertBoolToString(false)                       +",\r\n"+
					    "\"IsDistributed\":"                  + ConvertBoolToString(false)                       +",\r\n"+
					    "\"SHA1\": \""                        + sha1Hash                    +"\",\r\n"+
					    "\"MediaSize\": \""                   + mc.FileLength               +"\",\r\n"+
					    "\"RelativeFilePath\": \""            + calcFullPath                +"\",\r\n"+
					    "\"OffenderIdentified\":"             + ConvertBoolToString(false)                       +",\r\n"+
					    "\"IsPrecategorized\": "              + ConvertBoolToString(isPrecategorized)  +",\r\n"+
					    "\"PrecategorizationSource\": \""     + ""                          +"\",\r\n"+
					    "\"MimeType\": \""                    + "Image"                     +"\"\r\n}\r\n"; 


        // if necessary, reopen this file
        OpenIndexFile(true);

        // add the new record
        ReportIndex.WriteLine(lineValue);
    }

    String MakeCaseNote(){
        
        // Close up Shop
        String myNote;

        DateClass myEnd;
        myEnd.Now();

        // Terminate the Index file
        EndIndexFile();

        // Strategy
        String path = MyReportPath + "\\Victim Report.xml";
        if (!VictimReport.IsOpen()){
          if(!VictimReport.Open(path, FileClass::APPEND))
            MyConsole.WriteFullLine("Could not open: " + path);
        }

        VictimReport.WriteLine("  </VictimIndex>");
        VictimReport.Close();

        myNote = "Project VIC Carver EnScript:  \r\n" +
                 "Compile Date:  " + MyOptions.CompileDate + "\r\n" +
                 "Case Name:     " + MyOptions.CaseName + "\r\n\r\n" +
                 "Start Time:    " + MyOptions.StartDate + " " + MyOptions.StartTime +
                 "\r\n" +
                 "End Time:      " + myEnd.GetString("dd-MMM-yyyy", "HH-mm-ss", DateClass::GetTimeZoneBias()) +
                 "\r\n" +
                 "\r\n" +
                 FileCount
                  + " movies and pictures were found and extracted from " + MyOptions.EntryCount + " entries." +
                 "\r\n" +
                 "\r\n" + (Cat1 + Cat2 + Cat3 + Cat4 + Cat5 +
                           Cat6 + Cat7 + Cat8 + Cat9) + " were" +
                 " found in the database.\r\n" +
                 "Category 1: " + Cat1 + "\r\n" +
                 "Category 2: " + Cat2 + "\r\n" +
                 "Category 3: " + Cat3 + "\r\n" +
                 "Category 4: " + Cat4 + "\r\n" +
                 "Category 5: " + Cat5 + "\r\n" +
                 "Category 6: " + Cat6 + "\r\n" +
                 "Category 7: " + Cat7 + "\r\n" +
                 "Category 8: " + Cat8 + "\r\n" +
                 "Category 9: " + Cat9 + "\r\n";

        if(MyOptions.ExcludePreCatVal)
          myNote = myNote +
                 "\r\n" +
                 "Additionally, " + CatX + " image(s) were validated but NOT extracted.\r\n" +
                 "These were found in the Hash Database and excluded (as specified by the User)";
        EndCaseReport();

        return myNote;
    }

    void CloseVictimFile(){
        String path = MyReportPath + "\\Victim Report.xml";
        if (!VictimReport.IsOpen()){
            if(!VictimReport.Open(path, FileClass::APPEND))
                MyConsole.WriteFullLine("Could not open: " + path);
        }

        VictimReport.WriteLine("  </VictimIndex>");
        VictimReport.Close();
    }
    
    void MakeNewFolder(){
        if(!this) return;

        if(DiskId < 10)
            FolderName = "DVD0" + DiskId;
        else
            FolderName = "DVD" + DiskId;

        FolderName = FolderName + "(" + MyOptions.CaseName + ")";

        String path = MyReportPath + "\\" + FolderName;

        if(!LocalMachine.PathExists(path)){
            if(!LocalMachine.CreateFolder(path))
                MyConsole.WriteFullLine("Could not create the folder! (" + path + ")");
        }

        DiskId++;
        SubDiskId = 1;
        FolderSize = 0;
        ExportToFolderCount = 0;
        MakeNewSubFolder();
    }

    void MakeNewSubFolder(){
        if(!this) return;

        if(SubDiskId < 10)
            SubFolderName = "0" + SubDiskId;
        else
            SubFolderName = SubDiskId;

        String path = MyReportPath + "\\" + FolderName + "\\" + SubFolderName;
        if(!LocalMachine.PathExists(path)){
            if(!LocalMachine.CreateFolder(path))
                MyConsole.WriteFullLine("Could not create the sub-folder! (" + path + ")");
        }

        SubDiskId++;
        SubFolderSize = 0;
        ExportToFolderCount = 0;
    }

    void CopyOutZip(EntryClass entry, const String &path){
        if(!this) return;

        // Protected or Unmountable (in EnCase) Zip Volume - if desired, then copy this file out for cracking
        EntryFileClass ZIPfile();
        LocalFileClass ZIPout();

        MyOptions.ZipCount++;

        if(ZIPfile.Open(entry, FileClass::SLACK)){
            String outPath = MyOptions.ProtectedPath + PadNumber(MyOptions.ZipCount) + ".zip";

            if(ZIPout.Open(outPath, FileClass::WRITETEXTCRLF)){
                ZIPout.WriteBuffer(ZIPfile, entry.LogicalSize());

                if (!ZipReport.IsOpen()){
                    String outPath2 = MyReportPath + "\\Protected Files.txt";
                    if(ZipReport.Open(outPath2, FileClass::APPEND)){
                        ZipReport.WriteLine(PadNumber(MyOptions.ZipCount) + "*" + path + entry.FullPath());

                    } else
                        MyConsole.WriteFullLine("Could not open: " + outPath2);
                }
            } else
                MyConsole.WriteFullLine("Could not open: " + outPath );
        } else
            MyConsole.WriteFullLine("Could not open: " + path + entry.FullPath());
    }

    bool Extract(FileClass fc, CarveClass cc, const String &path, int count = 0){
        if(!this) return false;

        // If the file is already there, then don't copy it again (maybe??)
        if(!LocalMachine.PathExists(path))
        {

            LocalFileClass outFile();
            if (outFile.Open(path, FileClass::WRITETEXTCRLF)) {

                // If this is a memory file class, then the offset is ZERO, but otherwise we use the
                // CarveClass offset to get to the right spot in the EntryFileClass object
                if(cc.MF)
                    fc.Seek(0);
                else
                    fc.Seek(cc.Offset);

                outFile.WriteBuffer(fc, cc.FileLength);

                // Now verify the file was actually extracted
                if(!LocalMachine.PathExists(path)){
                    Console.WriteLine("File supposed to extract, but it didn't!  Failed Path: " + path);
                    count++;
                    if(count < 5)
                        return Extract(fc, cc, path, count);
                    else
                    {
                        if(MyOptions.IgnoreFailedExtract) {
                            // do something...should we bookmark?
                            Console.WriteLine("File could not be extracted.  Bookmarking instead: " + path);

                        AddPictureBookmark(FailedRoot, cc.Entry.Name(), "Could not Extract File", cc.Entry, cc.Offset, 10);
                        return false;
                        }
                        else {
                            Console.WriteLine("Extract attempted four times and failed every time.  Script cancelled.");
                            SystemClass::Exit();
                        }
                    }
                }


                // Put this into a Logical Evidence File as well, if requested
                if(MyOptions.CreateLef)
                {
                    // Back to the beginning of the output file
                    outFile.Seek(0);

                    LogicalEvidenceFileClass::DataClass data(null, "", 0);
                    data.Path = path.SubString(MyOptions.ReportPath.GetLength()+1);
                    data.SetTarget(outFile, LogicalEvidenceFileClass::DataClass::MODEFILE);

                    if (!MyOptions.Lef.Add(data)){
                        Console.WriteLine("Could not add file " + path + " to Logical evidence file.");
                        SystemClass::Exit();
                    }
                }

                outFile.Close();

                return true;

            }
            else {
                MyConsole.WriteFullLine("Failed to open local path: " + path);
                return false;
            }

            return false;
        }
        else
            return true;
    }

    void AddBookmark(CarveClass cc, const String &fileName){
        if(!this) return;

        if(MyOptions.MakeBookmarks){
            AddPictureBookmark(BookmarkRoot, cc.Entry.Name(), fileName, cc.Entry, cc.Offset, cc.FileLength);
        }
    }

    void _addVictimEntry(const String &victimPath, const String &hash){
        VictimReport.WriteLine("<Image>\r\n" +
                               "  <hash>"                + hash          + "</hash>\r\n" +
                               "  <path><![CDATA["       + victimPath    + "]]></path>\r\n" +
                               "</Image>\r\n");
        VictimReport.Close();
    }

    void AddVictimEntry(const String &victimPath, const String &hash){
        if(!this) return;

        if (victimPath != ""){
            if(!VictimReport.IsOpen()){
                String path = MyReportPath + "\\Victim Report.xml";

                if(VictimReport.Open(path, FileClass::APPEND)){
                    _addVictimEntry(victimPath, hash);
                } else
                    MyConsole.WriteFullLine("Could not open: " + path);
            }
            else {
                // For whatever reason the victim report is still open, so just write to it and then close
                _addVictimEntry(victimPath, hash);
            }
        
            MyOptions.VictimCount++;
        }
    }

    void CopyToLibrary(const String &path, const String &hash, const String &ext){
        if(!this) return;

        // If desired, copy this file into the Picture Library
        if(MyOptions.MakeLibrary && MyOptions.LibraryPath != ""){
            String tempPath = MyOptions.LibraryPath;

            tempPath = tempPath + "\\" + hash.SubString(0,1);
            if(!LocalMachine.PathExists(tempPath))
                LocalMachine.CreateFolder(tempPath);

            tempPath = tempPath + "\\" + hash.SubString(1,1);
            if(!LocalMachine.PathExists(tempPath))
                LocalMachine.CreateFolder(tempPath);

            tempPath = tempPath + "\\" + hash.SubString(2,1);
            if(!LocalMachine.PathExists(tempPath))
                LocalMachine.CreateFolder(tempPath);

            tempPath = tempPath + "\\" + hash + "." + ext;

            if(MyOptions.Debug)
                WriteDebug("OutputController", "Adding " + hash + " to Picture Library");

            if(!LocalMachine.PathExists(tempPath)){
                LocalFileClass lfSource();

                if(lfSource.Open(path)){
                    LocalFileClass lfTarget();

                    if(lfTarget.Open(tempPath, FileClass::WRITETEXTCRLF)){
                        lfTarget.WriteBuffer(lfSource, -1);
                        lfTarget.Close();
                        lfSource.Close();
                    } else
                        Console.WriteLine("Could not open: " + tempPath);
                } else
                    Console.WriteLine("Could not open: " + path);
            }
        }
    }

    void WriteResults(const String &msg){
        LocalFileClass lf();
        if (lf.Open(MyReportPath + "\\Results.txt", FileClass::WRITETEXTCRLF))
            lf.WriteLine(msg);
        else
            MyConsole.WriteFullLine("Could not copy the case report! (" + MyReportPath + "\\Case Report.xml)");
        lf.Close();
    }

    void SaveSettings(ActivePlugins plugins){
        LocalFileClass settings();
        if(settings.Open(MyOptions.ReportPath + "\\C4Allv2 - " + MyOptions.CaseName + "\\script settings.txt", FileClass::WRITE)){
            settings.SetCodePage(CodePageClass::ANSI);

            settings.WriteLine("Script Version:      " + MyOptions.VersionNum);
            settings.WriteLine("Script Compile Date: " + MyOptions.CompileDate);
            settings.WriteLine("");

            settings.WriteLine("Main Settings Page:");
            settings.WriteLine("===================");

            // C4P / C4M Disclosure Package Options
            settings.WriteLine("Create Package here:\t"+ MyOptions.ReportPath);

            if(MyOptions.MakeBookmarks)
                settings.WriteLine("Create a Bookmark for every file that is extracted?\tY");
            else
                settings.WriteLine("Create a Bookmark for every file that is extracted?\tN");

            if(MyOptions.CreateLef)
                settings.WriteLine("Preserve the C4All package in a LEF?\tY");
            else
                settings.WriteLine("Preserve the C4All package in a LEF?\tN");

            settings.WriteLine("Open the package folder upon completion?\t{0}", MyOptions.OpenReportFolder ? "Y" : "N");

            // Selected Files Options
            settings.WriteLine("");
            if(MyOptions.SearchSelected == 0)
                settings.WriteLine("Selected Files Options:\tSearch All Files");
            else if(MyOptions.SearchSelected == 1)
                settings.WriteLine("Selected Files Options:\tSearch All Tagged Files");
            else if(MyOptions.SearchSelected == 2)
                settings.WriteLine("Selected Files Options:\tExclude All Tagged Files");
            else if(MyOptions.SearchSelected == 3)
                settings.WriteLine("Selected Files Options:\tSearch Current View Only");

            // Pre-Categorization Options
            settings.WriteLine("");
            if(MyOptions.DbType == 0)
                settings.WriteLine("Pre-Categorization Options:\tNo Database");
            else if(MyOptions.DbType == 1){
                settings.WriteLine("Pre-Categorization Options:\tSQL Server");
                settings.WriteLine("\tServer Name:\t" + MyOptions.ServerName);
                settings.WriteLine("\tDatabase Name:\t" + MyOptions.DbName);
                settings.WriteLine("\tSQL Login:\t" + MyOptions.LoginName);
                settings.WriteLine("\tSQL Password:\t" + MyOptions.Password);
            }
            if(MyOptions.DbType == 2){
                settings.WriteLine("Pre-Categorization Options:\tmySQL");
                settings.WriteLine("\tComputer Name:\t" + MyOptions.ServerName);
                settings.WriteLine("\tODBC Connection String:\t" + MyOptions.ODBCstring);
            }
            if(MyOptions.MakeLibrary)
                settings.WriteLine("Populate Picture Librayr?\tY");
            else
                settings.WriteLine("Populate Picture Librayr?\tN");

            // Search Options
            settings.WriteLine("");
            if(MyOptions.IgnoreSmall)
                settings.WriteLine("Ignore Small Files?\tY");
            else
                settings.WriteLine("Ignore Small Files?\tN");

            // Debugging Options
            settings.WriteLine("");
            if(MyOptions.Debug)
                settings.WriteLine("Run in Debug Mode?\tY");
            else
                settings.WriteLine("Run in Debug Mode?\tN");

            if(MyOptions.DebugCurrentOnly)
                settings.WriteLine("Save Current Entry Only?\tY");
            else
                settings.WriteLine("Save Current Entry Only?\tN");

            if(MyOptions.IgnoreFailedExtract)
                settings.WriteLine("Bookmark Failed Extracts?\tY");
            else
                settings.WriteLine("Bookmark Failed Extracts?\tN");

            if(MyOptions.SaveConsole)
                settings.WriteLine("Save Console to disk?\tY");
            else
                settings.WriteLine("Save Console to disk?\tN");

            settings.WriteLine("");
            settings.WriteLine("");
            settings.WriteLine("Case Report Values:");
            settings.WriteLine("===================");
            settings.WriteLine("Case Name:\t" + MyOptions.CaseName);
            settings.WriteLine("Forensic Examiner:\t" + MyOptions.ForensicAnalyst);
            settings.WriteLine("Comments:\t" + MyOptions.Comments);


            settings.WriteLine("");
            settings.WriteLine("");
            settings.WriteLine("Exclusionary Options:");
            settings.WriteLine("===================");

            if(MyOptions.ExcludePreCatVal == 0)
                settings.WriteLine("Ignore a Cateogry:\tNone");
            else if(MyOptions.ExcludePreCatVal == 1)
                settings.WriteLine("Ignore a Cateogry:\tCategory 1");
            else if(MyOptions.ExcludePreCatVal == 2)
                settings.WriteLine("Ignore a Cateogry:\tCategory 2");
            else if(MyOptions.ExcludePreCatVal == 3)
                settings.WriteLine("Ignore a Cateogry:\tCategory 3");
            else if(MyOptions.ExcludePreCatVal == 4)
                settings.WriteLine("Ignore a Cateogry:\tCategory 4");
            else if(MyOptions.ExcludePreCatVal == 5)
                settings.WriteLine("Ignore a Cateogry:\tCategory 5");
            else if(MyOptions.ExcludePreCatVal == 6)
                settings.WriteLine("Ignore a Cateogry:\tCategory 6");
            else if(MyOptions.ExcludePreCatVal == 7)
                settings.WriteLine("Ignore a Cateogry:\tCategory 7");
            else if(MyOptions.ExcludePreCatVal == 8)
                settings.WriteLine("Ignore a Cateogry:\tCategory 8");
            else if(MyOptions.ExcludePreCatVal == 9)
                settings.WriteLine("Ignore a Cateogry:\tCategory 9");

            if(MyOptions.BookmarkExcludedPreCat)
                settings.WriteLine("Bookmark these pictures instead?\tY");
            else
                settings.WriteLine("Bookmark these pictures instead?\tN");

            // Unique Pictures
            settings.WriteLine("");
            if(MyOptions.ExportByHash)
                settings.WriteLine("Store Extracted Files by their MD5?\tY");
            else
                settings.WriteLine("Store Extracted Files by their MD5?\tN");



            settings.WriteLine("");
            settings.WriteLine("");
            settings.WriteLine("Plugins:");
            settings.WriteLine("===================");

            foreach(PluginList p in plugins.myPlugins){
                if(p.Plugin){
                    settings.WriteLine("Plugin: " + p.Plugin.PluginName());
                    settings.WriteLine("\tExtension:\t" + p.Plugin.Extension());
                    settings.WriteLine("\tVersion:\t" + p.Plugin.Version());
                    if(p.Plugin.Enabled())
                        settings.WriteLine("\tEnabled?\tY");
                    else
                        settings.WriteLine("\tEnabled?\tN");
                    settings.WriteLine("\tHeader:\t" + p.Plugin.Header());
                    settings.WriteLine("\tBytesPrecedingHeader:\t" + p.Plugin.BytesPrecedingHeader());
                    settings.WriteLine("\tRangeToIgnoreSearchHits:\t" + p.Plugin.RangeToIgnoreSearchHits());
                    settings.WriteLine("\tSmallFileLimit:\t" + p.Plugin.SmallFileLimit());
                    settings.WriteLine("");
                }
            }

            settings.Close();
        }
    }

}
    
    


